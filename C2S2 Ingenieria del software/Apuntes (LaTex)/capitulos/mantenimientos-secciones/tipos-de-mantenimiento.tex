\subsection{Leyes de Lehman}\label{subsec:leyes-de-lehman}
\begin{itemize}
    \item \textbf{Ley del cambio continuo.} En un entorno real, un sistema debe necesariamente cambiar para mantener su utilidad.
    \item \textbf{Ley de complejidad creciente.} Cuando el sistema evoluciona se hace más complejo.
    Hay que tomar medidas para evitarlo.
    \item \textbf{Ley de evolución. }La evolución es un proceso autorregulado.
    El tamaño, tiempo entre versiones, errores detectados, etc., se mantienen en el tiempo.
    \item \textbf{Ley de estabilidad organizacional.} Durante el tiempo de vida del sistema su velocidad de desarrollo es constante e independiente de los recursos dedicados su desarrollo.
    \item \textbf{Ley de conservación de la familiaridad.} A medida que un sistema evoluciona todo lo que está asociado con ello debe mantener un conocimiento total de su contenido y su comportamiento.
    \item \textbf{Ley de crecimiento continuado. }La funcionalidad ofrecida por los sistemas tiene que crecer continuamente para
    mantener la satisfacción de los usuarios.
    \item \textbf{Ley de decremento de la calidad.} La calidad de los sistemas software comenzará a disminuir a menos que dichos
    sistemas se adapten a los cambios de su entorno de funcionamiento.
    \item \textbf{Ley de retroalimentación.} Los procesos de evolución incorporan sistemas de retroalimentación.
\end{itemize}

\subsection{Proceso de mantenimiento}\label{subsec:proceso-de-mantenimiento}
\begin{itemize}
    \item \textbf{Causas de modificación:}
    \begin{itemize}
        \item Nuevos requisitos/cambios solicitados
        \item Corrección de errores
    \end{itemize}

    \item \textbf{Incorporación al desarrollo:}
    \begin{itemize}
        \item Implementación formal u hotfixes
    \end{itemize}

    \item \textbf{Factores de esfuerzo:}
    \begin{itemize}
        \item Diseño del sistema
        \item  Mecanismos de prueba
        \item Documentación
        \item  Estabilidad del personal
    \end{itemize}
\end{itemize}

\subsection{Clasificación de mantenimiento}\label{subsec:clasificacion-de-mantenimiento}
\begin{tabular}{|l|l|l|p{6cm}|c|}
    \hline
    \textbf{Categoría} & \textbf{Tipo} & \textbf{Descripción}          & \textbf{Esfuerzo} \\
    \hline
    Evolutivo          & Perfectivo    & Añadir nuevas funcionalidades & 50\%              \\
    \hline
    & Adaptativo    & Adaptar a nuevos entornos     & 25\%              \\
    \hline
    & Preventivo    & Mejorar mantenibilidad futura & 5\%               \\
    \hline
    Tradicional        & Correctivo    & Corregir errores              & 20\%              \\
    \hline
\end{tabular}

\subsection{Release Notes}\label{subsec:release-notes}
\begin{itemize}
    \item \textbf{Contenido esencial:}
    \begin{itemize}
        \item Novedades
        \item Mejoras
        \item Correcciones de errores
    \end{itemize}
\end{itemize}

\subsection{Sistemas heredados}\label{subsec:sistemas-heredados}
\begin{itemize}
    \item \textbf{Problemas comunes:}
    \begin{itemize}
        \item Código espagueti
        \item  Falta de documentación
        \item Estructura deficiente
        \item Especificaciones ausentes
    \end{itemize}

    \item \textbf{Solución:} Ingeniería inversa
\end{itemize}

\subsection{Reingeniería de sistemas}\label{subsec:reingenieria-de-sistemas}
\begin{definicion}
    Reestructuración, reescritura o re-documentación sin cambiar funcionalidad.
\end{definicion}

\begin{itemize}
    \item \textbf{Ventajas:} Más económico que desarrollo nuevo • Reemplazo gradual
    \item \textbf{Factores coste:} Personal experto, herramientas disponibles
    \item \textbf{¿Por qué?:} Más barato que el desarrollo.
\end{itemize}

\subsection{Tipos de reingeniería}\label{subsec:tipos-de-reingenieria}
\begin{itemize}
    \item Traducción de código
    \item Ingeniería inversa
    \item Reestructuración
    \item Ingeniería hacia adelante
    \item Migración de datos
\end{itemize}

\subsection{Flujo de reingeniería}\label{subsec:flujo-de-reingenieria}
\begin{enumerate}
    \item Código fuente sucio $\rightarrow$ Reestructuración $\rightarrow$ Código limpio
    \item Extracción de abstracciones $\rightarrow$ Especificación inicial
    \item Refinamiento $\rightarrow$ Especificación final
\end{enumerate}